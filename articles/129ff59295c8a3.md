---
title: "C言語最適化ーパワープログラマへの道（CSAPP第5章）"
emoji: "🧩"
type: "tech"
topics:
  - "c"
  - "最適化"
  - "csapp"
published: false
---

# C言語を最適化する

for文とwhile文って結局どっちが早いの？


C言語を始めたときに、一度は抱いたことのある疑問ではないでしょうか。


"唯一の最適解"がないプログラミングの中で、**より良い、よりスマートなコードを書きたい！** と最適化を目指す*情熱的なC言語プログラマ*（と自分）のために、最適化についてまとめました。


## 目次
[0.導入編](#0-導入編)
[1.実践編](#1-実践編)
[2.5 実践編++](#25-実践編)
[3.総集編](#3-総集編)


# 3. 総集編
結論を先に置いておきます。

##### 最適化とは：前菜　（[0. 導入編](#0-導入編)）


##### 基本的な最適化：コンパイラの最適化を助ける　（[1. 実践編](#1-実践編)）
:::message
コンパイラが効率的なコードを生成できるよう、最適化を防ぐ要件（最適化阻害要因）を避ける
:::
+ 関数呼び出しをできるだけループの外へ
+ 不要なメモリ参照を削除する
    + 途中の結果を保持するための変数（一時変数）を導入する
    + 最終値の計算時のみ（配列、グローバル変数）に代入する
  
##### 高難易度最適化：ハードウェアの性能をフル活用する　（[2. 実践編＋＋](#25-実践編)）

+  ループ・アンローリング　（オーバーヘッドを削減する）
+  命令レベルでの並列性を高める
    +  　複数の累積機の使用
    +  　再結合
    +  　条件分岐を条件付き移動に書き換える

:::message warn 
プログラムの最適化時には、バグが発生しやすい。
エラーが起きないか、元のコードとの完全な互換性があるか注意深く確認する必要がある。
:::


# 0. 導入編
### 我々はなぜ最適化方法を学ぶのか

プログラムを**最適化**すること**→**プログラムを**高速化**すること である。

小さなローカルのプログラムでは、最適化のもたらす利益は少ないが、大きなプログラムやネットワーク上のプログラムでは、*少しの最適化*が*大きな性能向上*につながる場合がある。

case0) **リアルタイム性**が求められるビデオ処理では低速なプログラムは機能要件を満たさない → 高速化が重要
case1) 処理が数日や数週間に及ぶ**膨大な計算量**を持つプログラムでは、わずか20％の高速化であっても、大きな性能向上になる → 高速化が重要

プログラムの要件にあったコードがかける、そして書いたコードを改善できるようになる


### コンパイラは既に有能である
gccなどのコンパイラ（正確にはコンパイラ・ドライバ）は、**高度な最適化アルゴリズム**を持つ。

ゆえに、最も基本的なプログラムの最適化方法とは、**コンパイラに最適化レベルを指定する**ということである。
これにより、コードを書き換えなくても、コンパイラが内部的に処理を最適化してくれるようになる（ez！）

```bash
gcc -O2 main.c
```
:::message info
-O2 をつけてコンパイル
:::

gccの場合には、実行の際のコマンドラインオプションに`-Og` (*Optimize*)を追加することで基本的な最適化が適用される

そのほかに`-O0` `-O1` `-O2` `-O3`などの最適化オプションがある。gccを用いる多くのプロジェクトなどで、`-O2`が標準的に使用されているため、おそらく最適化フラグは`-O2`を用いるのが無難だろう。

過度な最適化にはトレードオフもある。ツールを用いたデバッグが難しくなったり、プログラムのサイズが大きくなる可能性がある。またプログラムによっては挙動が変化することもないとは限らない。それゆえ`-O3`でなく`-O2`というわけだ。


それぞれの最適化レベルの詳細は、以下のgccドキュメントをご参照いただきたい。

https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html



### 有能なコンパイラの有能な使い手に


ただし、コンパイラの自動最適化には**限界**がある。
これは、コンバイラが**保守的な最適化**を行うことに由来する。

保守的な最適化、とは、最適化によって結果が変化してしまう可能性のある場合には**コンパイラは最適化を避ける**、ということである。
*コンパイラの最適化を制限する要素*をまとめて**最適化阻害要因**、と呼ぶ。最適化阻害要因を減らすことで、コンパイラがより最適化できるようになる。

つまり、プログラマがコンパイラの最適化を最大限に活用するためには、最適化阻害要因を減らし、コンパイラが効率的なコード生成を行えるようなコードに書き換える必要がある。

例えば以下のコードを考える

```c:code A
*xp += *yp
*xp += *yp
```
このコードは、以下のように最適化できるように思われる。

```c:code B
*xp = 2 * *xp
```
ただし、これらのコードはもし`xp`と`yp`が同一のメモリを指していた場合、つまり`xp == yp`の場合には、異なる結果をもたらす。
挙動が

# 1. 実践編



# 2.5 実践編＋＋

！性能測定の実験が必要＝実用的ではない？


## ループアンローリング
:::message
並列実行できる演算を増やす（アウト・オブ・オーダ実行環境の場合のみ）
→クリティカル・パス（次のループが前のループを待つ）を減らす
:::

＊加算、乗算の結合性（括弧で括っても結果が変わらない）

#### 複数の変数に分けて計算して後でまとめる　（複数の累積機）

```c
acc0 = acc0 OP a[i]
acc1 = acc1 OP a[i + 1]
```
:::message warn
アンローリングを増やしすぎると、かえって非効率になる。
:::
　並列実行される命令が利用可能レジスタ数を超える
　→　スタックが使用され、メモリ読み出し、書き戻しの命令が増える（レジスタ・スピルの発生）


#### 演算の順序を括弧で指定する　（再結合変換）

整数加算を除けば（つまり整数乗算、浮動小数点加算、浮動小数点乗算では）、以下も同等の効率化を実現する。

```c
acc = acc OP (a[i] OP a[i + 1])
```

:::message warn
オーバーフロー、アンダーフローする可能性のある浮動小数点演算では、結果が異なる場合がある
:::

## 条件付きデータ転送（条件付き移動命令の使用）
###### :beginner: background infomation　分岐予測、分岐予測ミス・ペナルティーについて

コンパイラは複数命令を同時に処理する（効率化）ために、現在実行されている命令よりも**先の命令**を読み込んでいる。

この効率化がプログラムの性能に影響を与えるのが、`if`文などによる**条件分岐**である。
条件分岐の結果によって、既に読み込まれた先の命令が、*実際には実行されない命令*（無駄な処理）となる場合がある。この無駄を減らすために、コンパイラはこれまた高度な**分岐予測プログラム**を搭載している。

でも、もちろん予測が外れることもある。（40％ぐらいある。結構よくある。）
この分岐予測ミスが起きたときに起きる性能的損失を*分岐予測ミス・ペナルティー*とよぶ。
この分岐予測ミス・ペナルティーを減らすことも、無論プログラムの最適化につながる。


----

:::message
条件分岐を書き換えられるときには書き換えて、分岐予測を使わない
= 分岐予測ミス・ペナルティーがなくなる
:::

# [4. 総集編再放送](#3-総集編)

必要に応じてご利用ください。


## 参照
本記事はコンピュータ・システム プログラマの視点から (Computer Systems: A Programmer's Perspective)、通称CSAPPを読んで実践的な部分を厳選しまとめたものです。低レイヤを理解できる面白さがつまった本です。ただし買うのにはかなり勇気が入りました。


https://www.amazon.co.jp/%E3%82%B3%E3%83%B3%E3%83%94%E3%83%A5%E3%83%BC%E3%82%BF%E3%83%BB%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0-%E4%BA%94%E5%B3%B6-%E6%AD%A3%E8%A3%95/dp/4621302019





